syntax = "proto3";

package session.v1;

option go_package = "github.com/louisbranch/fracturing.space/api/gen/go/session/v1;sessionv1";

import "common/v1/rng.proto";
import "session/v1/session.proto";
import "session/v1/events.proto";

message StartSessionRequest {
  // The campaign ID to start a session for.
  string campaign_id = 1;

  // Optional free-form name for the session.
  string name = 2;
}

message StartSessionResponse {
  Session session = 1;
}

message ListSessionsRequest {
  // The campaign ID to list sessions for.
  string campaign_id = 1;

  // The maximum number of sessions to return.
  // If zero, the server defaults to 10. The server clamps values above 10 to 10.
  int32 page_size = 2;

  // A page token received from a prior ListSessionsResponse.
  string page_token = 3;
}

message ListSessionsResponse {
  repeated Session sessions = 1;
  string next_page_token = 2;
}

message GetSessionRequest {
  // The campaign ID.
  string campaign_id = 1;

  // The session ID.
  string session_id = 2;
}

message GetSessionResponse {
  Session session = 1;
}

message EndSessionRequest {
  // The campaign ID.
  string campaign_id = 1;

  // The session ID.
  string session_id = 2;
}

message EndSessionResponse {
  Session session = 1;
}

message SessionEventAppendRequest {
  // The session ID to append the event to.
  string session_id = 1;

  // The event type.
  SessionEventType type = 2;

  // Optional participant identifier for correlation.
  string participant_id = 3;

  // Optional character identifier for correlation.
  string character_id = 4;

  // JSON payload encoded as bytes.
  bytes payload_json = 5;
}

message SessionEventAppendResponse {
  SessionEvent event = 1;
}

message SessionEventsListRequest {
  // The session ID to list events for.
  string session_id = 1;

  // Return events with seq greater than this value.
  uint64 after_seq = 2;

  // Maximum number of events to return.
  int32 limit = 3;
}

message SessionEventsListResponse {
  repeated SessionEvent events = 1;
}

message ActionRollModifier {
  string source = 1;
  int32 value = 2;
}

message SessionActionRollRequest {
  // The campaign ID for validation.
  string campaign_id = 1;

  // The session ID to associate with this roll.
  string session_id = 2;

  // The character performing the roll.
  string character_id = 3;

  // The trait being rolled.
  string trait = 4;

  // The difficulty target.
  int32 difficulty = 5;

  // Optional modifiers applied to the roll.
  repeated ActionRollModifier modifiers = 6;

  // Optional RNG configuration for deterministic rolls.
  common.v1.RngRequest rng = 7;
}

message SessionActionRollResponse {
  uint64 roll_seq = 1;
  int32 hope_die = 2;
  int32 fear_die = 3;
  int32 total = 4;
  int32 difficulty = 5;
  bool success = 6;
  string flavor = 7;
  bool crit = 8;
  common.v1.RngResponse rng = 9;
}

message ApplyRollOutcomeRequest {
  // The session ID to apply the outcome within.
  string session_id = 1;

  // The roll sequence number of the ACTION_ROLL_RESOLVED event.
  uint64 roll_seq = 2;

  // Optional list of character IDs to apply the outcome to.
  // If omitted, defaults to the roller character in the roll event.
  repeated string targets = 3;
}

message OutcomeCharacterState {
  string character_id = 1;
  int32 hope = 2;
  int32 stress = 3;
  int32 hp = 4;
}

message OutcomeUpdated {
  repeated OutcomeCharacterState character_states = 1;
  optional int32 gm_fear = 2;
}

message ApplyRollOutcomeResponse {
  uint64 roll_seq = 1;
  bool requires_complication = 2;
  OutcomeUpdated updated = 3;
}
