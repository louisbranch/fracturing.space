syntax = "proto3";

package game.v1;

import "game/v1/participant.proto";

option go_package = "github.com/louisbranch/fracturing.space/api/gen/go/game/v1;gamev1";

// AuthorizationAction identifies the requested operation class.
enum AuthorizationAction {
  AUTHORIZATION_ACTION_UNSPECIFIED = 0;
  AUTHORIZATION_ACTION_READ = 1;
  AUTHORIZATION_ACTION_MANAGE = 2;
  AUTHORIZATION_ACTION_MUTATE = 3;
  AUTHORIZATION_ACTION_TRANSFER_OWNERSHIP = 4;
}

// AuthorizationResource identifies the campaign-scoped resource type.
enum AuthorizationResource {
  AUTHORIZATION_RESOURCE_UNSPECIFIED = 0;
  AUTHORIZATION_RESOURCE_CAMPAIGN = 1;
  AUTHORIZATION_RESOURCE_PARTICIPANT = 2;
  AUTHORIZATION_RESOURCE_INVITE = 3;
  AUTHORIZATION_RESOURCE_SESSION = 4;
  AUTHORIZATION_RESOURCE_CHARACTER = 5;
}

// ParticipantGovernanceOperation identifies participant-manage operation intent.
enum ParticipantGovernanceOperation {
  PARTICIPANT_GOVERNANCE_OPERATION_UNSPECIFIED = 0;
  PARTICIPANT_GOVERNANCE_OPERATION_MUTATE = 1;
  PARTICIPANT_GOVERNANCE_OPERATION_ACCESS_CHANGE = 2;
  PARTICIPANT_GOVERNANCE_OPERATION_REMOVE = 3;
}

// AuthorizationTarget carries optional target context for richer policy checks.
message AuthorizationTarget {
  // Optional resource ID (for example participant or character id).
  string resource_id = 1;

  // Optional character owner participant id.
  string owner_participant_id = 2;

  // Optional participant-id target for participant governance checks.
  string target_participant_id = 3;

  // Optional current access level for participant target.
  CampaignAccess target_campaign_access = 4;

  // Optional requested access level for participant mutations.
  CampaignAccess requested_campaign_access = 5;

  // Optional participant-governance operation intent.
  ParticipantGovernanceOperation participant_operation = 6;
}

message CanRequest {
  // The campaign being evaluated.
  string campaign_id = 1;

  // The requested action.
  AuthorizationAction action = 2;

  // The requested resource.
  AuthorizationResource resource = 3;

  // Optional target context.
  AuthorizationTarget target = 4;
}

message CanResponse {
  // True when policy allows the operation.
  bool allowed = 1;

  // Stable machine-readable reason code.
  string reason_code = 2;

  // Resolved actor campaign access when available.
  CampaignAccess actor_campaign_access = 3;

  // Resolved actor participant id when available.
  string actor_participant_id = 4;
}

// BatchCanCheck describes a single authorization check inside a batch request.
message BatchCanCheck {
  // Optional client correlation id echoed back in response.
  string check_id = 1;

  // The campaign being evaluated.
  string campaign_id = 2;

  // The requested action.
  AuthorizationAction action = 3;

  // The requested resource.
  AuthorizationResource resource = 4;

  // Optional target context.
  AuthorizationTarget target = 5;
}

// BatchCanRequest groups multiple campaign authorization checks.
message BatchCanRequest {
  repeated BatchCanCheck checks = 1;
}

// BatchCanResult is the decision for one batch check.
message BatchCanResult {
  // Client correlation id copied from request.
  string check_id = 1;

  // True when policy allows the operation.
  bool allowed = 2;

  // Stable machine-readable reason code.
  string reason_code = 3;

  // Resolved actor campaign access when available.
  CampaignAccess actor_campaign_access = 4;

  // Resolved actor participant id when available.
  string actor_participant_id = 5;
}

// BatchCanResponse returns decisions for all request checks in request order.
message BatchCanResponse {
  repeated BatchCanResult results = 1;
}

// AuthorizationService exposes campaign authorization checks.
service AuthorizationService {
  // Can evaluates whether the caller may perform action/resource in campaign.
  rpc Can(CanRequest) returns (CanResponse);

  // BatchCan evaluates authorization for multiple checks in one request.
  rpc BatchCan(BatchCanRequest) returns (BatchCanResponse);
}
