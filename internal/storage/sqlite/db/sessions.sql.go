// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package db

import (
	"context"
	"database/sql"
)

const clearActiveSession = `-- name: ClearActiveSession :exec
DELETE FROM campaign_active_session WHERE campaign_id = ?
`

func (q *Queries) ClearActiveSession(ctx context.Context, campaignID string) error {
	_, err := q.db.ExecContext(ctx, clearActiveSession, campaignID)
	return err
}

const getActiveSession = `-- name: GetActiveSession :one
SELECT s.campaign_id, s.id, s.name, s.status, s.started_at, s.updated_at, s.ended_at FROM sessions s
JOIN campaign_active_session cas ON s.campaign_id = cas.campaign_id AND s.id = cas.session_id
WHERE s.campaign_id = ?
`

func (q *Queries) GetActiveSession(ctx context.Context, campaignID string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getActiveSession, campaignID)
	var i Session
	err := row.Scan(
		&i.CampaignID,
		&i.ID,
		&i.Name,
		&i.Status,
		&i.StartedAt,
		&i.UpdatedAt,
		&i.EndedAt,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT campaign_id, id, name, status, started_at, updated_at, ended_at FROM sessions WHERE campaign_id = ? AND id = ?
`

type GetSessionParams struct {
	CampaignID string `json:"campaign_id"`
	ID         string `json:"id"`
}

func (q *Queries) GetSession(ctx context.Context, arg GetSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSession, arg.CampaignID, arg.ID)
	var i Session
	err := row.Scan(
		&i.CampaignID,
		&i.ID,
		&i.Name,
		&i.Status,
		&i.StartedAt,
		&i.UpdatedAt,
		&i.EndedAt,
	)
	return i, err
}

const hasActiveSession = `-- name: HasActiveSession :one
SELECT EXISTS(SELECT 1 FROM campaign_active_session WHERE campaign_id = ?) as has_active
`

func (q *Queries) HasActiveSession(ctx context.Context, campaignID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, hasActiveSession, campaignID)
	var has_active int64
	err := row.Scan(&has_active)
	return has_active, err
}

const listSessionsByCampaign = `-- name: ListSessionsByCampaign :many
SELECT campaign_id, id, name, status, started_at, updated_at, ended_at FROM sessions
WHERE campaign_id = ?
ORDER BY id
`

func (q *Queries) ListSessionsByCampaign(ctx context.Context, campaignID string) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsByCampaign, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.CampaignID,
			&i.ID,
			&i.Name,
			&i.Status,
			&i.StartedAt,
			&i.UpdatedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsByCampaignPaged = `-- name: ListSessionsByCampaignPaged :many
SELECT campaign_id, id, name, status, started_at, updated_at, ended_at FROM sessions
WHERE campaign_id = ? AND id > ?
ORDER BY id
LIMIT ?
`

type ListSessionsByCampaignPagedParams struct {
	CampaignID string `json:"campaign_id"`
	ID         string `json:"id"`
	Limit      int64  `json:"limit"`
}

func (q *Queries) ListSessionsByCampaignPaged(ctx context.Context, arg ListSessionsByCampaignPagedParams) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsByCampaignPaged, arg.CampaignID, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.CampaignID,
			&i.ID,
			&i.Name,
			&i.Status,
			&i.StartedAt,
			&i.UpdatedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsByCampaignPagedFirst = `-- name: ListSessionsByCampaignPagedFirst :many
SELECT campaign_id, id, name, status, started_at, updated_at, ended_at FROM sessions
WHERE campaign_id = ?
ORDER BY id
LIMIT ?
`

type ListSessionsByCampaignPagedFirstParams struct {
	CampaignID string `json:"campaign_id"`
	Limit      int64  `json:"limit"`
}

func (q *Queries) ListSessionsByCampaignPagedFirst(ctx context.Context, arg ListSessionsByCampaignPagedFirstParams) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsByCampaignPagedFirst, arg.CampaignID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.CampaignID,
			&i.ID,
			&i.Name,
			&i.Status,
			&i.StartedAt,
			&i.UpdatedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const putSession = `-- name: PutSession :exec
INSERT INTO sessions (
    campaign_id, id, name, status, started_at, updated_at, ended_at
) VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(campaign_id, id) DO UPDATE SET
    name = excluded.name,
    status = excluded.status,
    updated_at = excluded.updated_at,
    ended_at = excluded.ended_at
`

type PutSessionParams struct {
	CampaignID string         `json:"campaign_id"`
	ID         string         `json:"id"`
	Name       string         `json:"name"`
	Status     string         `json:"status"`
	StartedAt  string         `json:"started_at"`
	UpdatedAt  string         `json:"updated_at"`
	EndedAt    sql.NullString `json:"ended_at"`
}

func (q *Queries) PutSession(ctx context.Context, arg PutSessionParams) error {
	_, err := q.db.ExecContext(ctx, putSession,
		arg.CampaignID,
		arg.ID,
		arg.Name,
		arg.Status,
		arg.StartedAt,
		arg.UpdatedAt,
		arg.EndedAt,
	)
	return err
}

const setActiveSession = `-- name: SetActiveSession :exec
INSERT INTO campaign_active_session (campaign_id, session_id)
VALUES (?, ?)
ON CONFLICT(campaign_id) DO UPDATE SET
    session_id = excluded.session_id
`

type SetActiveSessionParams struct {
	CampaignID string `json:"campaign_id"`
	SessionID  string `json:"session_id"`
}

func (q *Queries) SetActiveSession(ctx context.Context, arg SetActiveSessionParams) error {
	_, err := q.db.ExecContext(ctx, setActiveSession, arg.CampaignID, arg.SessionID)
	return err
}

const updateSessionStatus = `-- name: UpdateSessionStatus :exec
UPDATE sessions
SET status = ?, updated_at = ?, ended_at = ?
WHERE campaign_id = ? AND id = ?
`

type UpdateSessionStatusParams struct {
	Status     string         `json:"status"`
	UpdatedAt  string         `json:"updated_at"`
	EndedAt    sql.NullString `json:"ended_at"`
	CampaignID string         `json:"campaign_id"`
	ID         string         `json:"id"`
}

func (q *Queries) UpdateSessionStatus(ctx context.Context, arg UpdateSessionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateSessionStatus,
		arg.Status,
		arg.UpdatedAt,
		arg.EndedAt,
		arg.CampaignID,
		arg.ID,
	)
	return err
}
