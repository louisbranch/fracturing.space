package main

// Package main generates documentation catalogs for domain events and commands.
//
// This utility is intentionally read-only and lives near the API boundary so
// onboarding can regenerate docs after domain/event language changes.

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"unicode"
)

type eventDef struct {
	Owner     string
	Name      string
	Value     string
	DefinedAt string
	Payload   string
}

type commandDef struct {
	Owner         string
	Name          string
	Value         string
	GateScope     string
	AllowWhenOpen bool
	DefinedAt     string
}

type payloadField struct {
	Name    string
	Type    string
	JSONTag string
}

type payloadDef struct {
	Owner     string
	Name      string
	DefinedAt string
	Fields    []payloadField
}

const generatedByLine = "Generated by `go run ./internal/tools/eventdocgen`.\n\n"

type packageDefs struct {
	Events   []eventDef
	Payloads map[string]payloadDef
}

func main() {
	var outPath string
	var usageOutPath string
	var commandsOutPath string
	var rootFlag string
	flag.StringVar(&outPath, "out", "docs/events/event-catalog.md", "output path for the catalog")
	flag.StringVar(&usageOutPath, "usage-out", "docs/events/usage-map.md", "output path for the usage map")
	flag.StringVar(&commandsOutPath, "commands-out", "docs/events/command-catalog.md", "output path for the command catalog")
	flag.StringVar(&rootFlag, "root", "", "repo root (defaults to locating go.mod)")
	flag.Parse()

	root, err := resolveRoot(rootFlag)
	if err != nil {
		fatal(err)
	}
	catalogOutput := outPath
	if !filepath.IsAbs(catalogOutput) {
		catalogOutput = filepath.Join(root, outPath)
	}
	usageOutput := usageOutPath
	if !filepath.IsAbs(usageOutput) {
		usageOutput = filepath.Join(root, usageOutPath)
	}
	commandsOutput := strings.TrimSpace(commandsOutPath)
	if commandsOutput != "" && !filepath.IsAbs(commandsOutput) {
		commandsOutput = filepath.Join(root, commandsOutput)
	}

	eventPackageGroups := []struct {
		dir   string
		owner string
	}{
		{dir: filepath.Join(root, "internal/services/game/domain/campaign"), owner: "Core"},
		{dir: filepath.Join(root, "internal/services/game/domain/character"), owner: "Core"},
		{dir: filepath.Join(root, "internal/services/game/domain/invite"), owner: "Core"},
		{dir: filepath.Join(root, "internal/services/game/domain/participant"), owner: "Core"},
		{dir: filepath.Join(root, "internal/services/game/domain/session"), owner: "Core"},
		{dir: filepath.Join(root, "internal/services/game/domain/action"), owner: "Core"},
		{dir: filepath.Join(root, "internal/services/game/domain/systems/daggerheart"), owner: "Daggerheart"},
	}
	definitions := make([]packageDefs, 0, len(eventPackageGroups))
	for _, pkg := range eventPackageGroups {
		definitionsForPackage, err := parsePackage(pkg.dir, root, pkg.owner)
		if err != nil {
			fatal(err)
		}
		definitions = append(definitions, definitionsForPackage)
	}

	valueByConstant := buildEventValueLookup(definitions)
	emitterValues, err := scanEmitterValues(filepath.Join(root, "internal/services/game"), root, valueByConstant)
	if err != nil {
		fatal(err)
	}
	content, err := renderCatalog(definitions, emitterValues)
	if err != nil {
		fatal(err)
	}
	if err := writeOutput(catalogOutput, content, "catalog"); err != nil {
		fatal(err)
	}
	appliers, err := scanAppliers(filepath.Join(root, "internal/services/game"), root, valueByConstant)
	if err != nil {
		fatal(err)
	}
	usageContent, err := renderUsageMap(definitions, emitterValues, appliers)
	if err != nil {
		fatal(err)
	}
	if err := writeOutput(usageOutput, usageContent, "usage map"); err != nil {
		fatal(err)
	}

	if commandsOutput != "" {
		commandPackages := []struct {
			dir   string
			owner string
		}{
			{dir: filepath.Join(root, "internal/services/game/domain/campaign"), owner: "Core"},
			{dir: filepath.Join(root, "internal/services/game/domain/action"), owner: "Core"},
			{dir: filepath.Join(root, "internal/services/game/domain/session"), owner: "Core"},
			{dir: filepath.Join(root, "internal/services/game/domain/participant"), owner: "Core"},
			{dir: filepath.Join(root, "internal/services/game/domain/invite"), owner: "Core"},
			{dir: filepath.Join(root, "internal/services/game/domain/character"), owner: "Core"},
			{dir: filepath.Join(root, "internal/services/game/domain/systems/daggerheart"), owner: "System"},
		}
		commandMap := make(map[string]commandDef)
		for _, pkg := range commandPackages {
			definitions, err := parseCommandPackage(pkg.dir, root, pkg.owner)
			if err != nil {
				fatal(err)
			}
			mergeCommandDefinitions(commandMap, definitions)
		}
		commandDefinitions := commandDefinitionsFromMap(commandMap)
		commandContent, err := renderCommandCatalog(commandDefinitions)
		if err != nil {
			fatal(err)
		}
		if err := writeOutput(commandsOutput, commandContent, "command catalog"); err != nil {
			fatal(err)
		}
	}
}

func writeOutput(path, content, label string) error {
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return fmt.Errorf("create %s output dir: %w", label, err)
	}
	if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
		return fmt.Errorf("write %s: %w", label, err)
	}
	return nil
}

func resolveRoot(flagRoot string) (string, error) {
	if flagRoot != "" {
		return filepath.Clean(flagRoot), nil
	}
	wd, err := os.Getwd()
	if err != nil {
		return "", fmt.Errorf("get working dir: %w", err)
	}
	return findModuleRoot(wd)
}

func findModuleRoot(start string) (string, error) {
	dir := start
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return "", fmt.Errorf("go.mod not found above %s", start)
}

func parsePackage(dir, root, owner string) (packageDefs, error) {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, func(info os.FileInfo) bool {
		return !strings.HasSuffix(info.Name(), "_test.go")
	}, parser.AllErrors)
	if err != nil {
		return packageDefs{}, fmt.Errorf("parse %s: %w", dir, err)
	}
	defs := packageDefs{Payloads: make(map[string]payloadDef)}
	for _, pkg := range pkgs {
		files := make([]*ast.File, 0, len(pkg.Files))
		typeSpecs := make(map[string]ast.Expr)
		eventValues := make(map[string]string)
		for _, file := range pkg.Files {
			files = append(files, file)
			for _, decl := range file.Decls {
				gen, ok := decl.(*ast.GenDecl)
				if !ok || gen.Tok != token.TYPE {
					continue
				}
				for _, spec := range gen.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}
					typeSpecs[typeSpec.Name.Name] = typeSpec.Type
				}
			}
			importAliases := parseImportAliases(file)
			for name, value := range buildEventLocalConstLookup(file, importAliases, root) {
				eventValues[name] = value
			}
		}
		definitionsByValue := make(map[string]string)
		for _, file := range files {
			collectEventDefinitionPayloads(file, fset, root, owner, eventValues, definitionsByValue)
		}
		for _, file := range pkg.Files {
			importAliases := parseImportAliases(file)
			ast.Inspect(file, func(node ast.Node) bool {
				switch typed := node.(type) {
				case *ast.GenDecl:
					if typed.Tok == token.CONST {
						defs.Events = append(defs.Events, parseConstDecl(typed, fset, root, owner, importAliases)...)
					}
					if typed.Tok == token.TYPE {
						for _, spec := range typed.Specs {
							typeSpec, ok := spec.(*ast.TypeSpec)
							if !ok {
								continue
							}
							name := typeSpec.Name.Name
							if !strings.HasSuffix(name, "Payload") {
								continue
							}
							payloadFields, definedAt, ok := parsePayloadFromTypeExpr(typeSpec.Type, fset, importAliases, root, typeSpecs, map[string]struct{}{name: {}})
							if !ok {
								continue
							}
							payload := payloadDef{
								Owner:     owner,
								Name:      name,
								DefinedAt: definedAt,
								Fields:    payloadFields,
							}
							defs.Payloads[name] = payload
						}
					}
				}
				return true
			})
		}
		for i := range defs.Events {
			if payload, ok := definitionsByValue[defs.Events[i].Value]; ok {
				defs.Events[i].Payload = payload
			}
		}
	}
	defs.Events = dedupeEventDefinitionsByValue(defs.Events)
	for i := range defs.Events {
		defs.Events[i].Owner = owner
	}
	return defs, nil
}

func dedupeEventDefinitionsByValue(events []eventDef) []eventDef {
	byValue := make(map[string]eventDef)
	for _, event := range events {
		if strings.TrimSpace(event.Value) == "" {
			continue
		}
		existing, ok := byValue[event.Value]
		if !ok || shouldReplaceEventDefinition(event, existing) {
			byValue[event.Value] = event
		}
	}
	result := make([]eventDef, 0, len(byValue))
	for _, event := range byValue {
		result = append(result, event)
	}
	return result
}

func shouldReplaceEventDefinition(candidate, current eventDef) bool {
	candidatePriority := eventDefinitionPriority(candidate.Name)
	currentPriority := eventDefinitionPriority(current.Name)
	if candidatePriority != currentPriority {
		return candidatePriority < currentPriority
	}
	return candidate.Name < current.Name
}

func eventDefinitionPriority(name string) int {
	switch {
	case strings.HasPrefix(name, "eventType"):
		return 0
	case strings.HasPrefix(name, "Type"):
		return 1
	case strings.HasPrefix(name, "EventType"):
		return 2
	default:
		return 3
	}
}

func buildEventLocalConstLookup(file *ast.File, importAliases map[string]string, root string) map[string]string {
	result := make(map[string]string)
	for _, decl := range file.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok != token.CONST {
			continue
		}
		for _, spec := range gen.Specs {
			valueSpec, ok := spec.(*ast.ValueSpec)
			if !ok {
				continue
			}
			for i, name := range valueSpec.Names {
				expr := selectValueExpr(valueSpec.Values, i)
				if expr == nil {
					continue
				}
				value, ok := constantValue(expr, importAliases, root)
				if !ok || strings.TrimSpace(value) == "" {
					continue
				}
				result[name.Name] = value
			}
		}
	}
	return result
}

func collectEventDefinitionPayloads(file *ast.File, fset *token.FileSet, root, owner string, eventValues map[string]string, output map[string]string) {
	ast.Inspect(file, func(node ast.Node) bool {
		call, ok := node.(*ast.CallExpr)
		if ok {
			selector, ok := call.Fun.(*ast.SelectorExpr)
			if ok && selector.Sel != nil && selector.Sel.Name == "Register" && len(call.Args) == 1 {
				if definition, ok := parseEventDefinitionLiteral(call.Args[0], fset, root, owner, eventValues); ok && definition.Value != "" && definition.Payload != "" {
					output[definition.Value] = definition.Payload
					return true
				}
			}
		}
		composite, ok := node.(*ast.CompositeLit)
		if ok {
			collectEventDefinitionsFromComposite(composite, fset, root, owner, eventValues, output)
		}
		return true
	})
}

func collectEventDefinitionsFromComposite(lit *ast.CompositeLit, fset *token.FileSet, root, owner string, eventValues map[string]string, output map[string]string) {
	switch typed := lit.Type.(type) {
	case *ast.ArrayType:
		if !isEventDefinitionType(typed.Elt) {
			return
		}
		for _, element := range lit.Elts {
			definitionLit, ok := element.(*ast.CompositeLit)
			if !ok {
				continue
			}
			definition, ok := parseEventDefinitionLiteral(definitionLit, fset, root, owner, eventValues)
			if ok && definition.Value != "" && definition.Payload != "" {
				output[definition.Value] = definition.Payload
			}
		}
	case *ast.SelectorExpr, *ast.Ident:
		if !isEventDefinitionType(typed) {
			return
		}
		definition, ok := parseEventDefinitionLiteral(lit, fset, root, owner, eventValues)
		if ok && definition.Value != "" && definition.Payload != "" {
			output[definition.Value] = definition.Payload
		}
	}
}

func isEventDefinitionType(expr ast.Expr) bool {
	if typed, ok := expr.(*ast.SelectorExpr); ok {
		selector, ok := typed.X.(*ast.Ident)
		if !ok || typed.Sel == nil {
			return false
		}
		return selector.Name == "event" && typed.Sel.Name == "Definition"
	}
	if typed, ok := expr.(*ast.Ident); ok {
		return typed.Name == "Definition"
	}
	return false
}

func parseEventDefinitionLiteral(node ast.Expr, fset *token.FileSet, root, owner string, eventValues map[string]string) (eventDef, bool) {
	definition := eventDef{Owner: owner}
	literal, ok := node.(*ast.CompositeLit)
	if !ok || len(literal.Elts) == 0 {
		return definition, false
	}
	for _, elt := range literal.Elts {
		kv, ok := elt.(*ast.KeyValueExpr)
		if !ok {
			continue
		}
		key, ok := kv.Key.(*ast.Ident)
		if !ok {
			continue
		}
		switch key.Name {
		case "Type":
			definition.Value = eventValueFromExpr(kv.Value, eventValues)
		case "ValidatePayload":
			definition.Payload = parseEventValidatePayload(kv.Value)
		}
	}
	definition.DefinedAt = formatPosition(fset.Position(literal.Pos()), root)
	return definition, strings.TrimSpace(definition.Value) != ""
}

func parseEventValidatePayload(expr ast.Expr) string {
	ident, ok := expr.(*ast.Ident)
	if !ok {
		selector, ok := expr.(*ast.SelectorExpr)
		if !ok || selector.Sel == nil {
			return ""
		}
		ident = selector.Sel
	}
	name := ident.Name
	if name == "" {
		return ""
	}
	if !strings.HasPrefix(name, "validate") || !strings.HasSuffix(name, "Payload") {
		return ""
	}
	payload := strings.TrimPrefix(name, "validate")
	if payload == name {
		return ""
	}
	return payload
}

func parseCommandPackage(dir, root, owner string) ([]commandDef, error) {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, func(info os.FileInfo) bool {
		return !strings.HasSuffix(info.Name(), "_test.go")
	}, parser.AllErrors)
	if err != nil {
		return nil, fmt.Errorf("parse %s: %w", dir, err)
	}

	commandValues := make(map[string]string)
	byValue := make(map[string]commandDef)

	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			importAliases := parseImportAliases(file)
			for _, decl := range file.Decls {
				gen, ok := decl.(*ast.GenDecl)
				if !ok || gen.Tok != token.CONST {
					continue
				}
				for _, spec := range gen.Specs {
					valueSpec, ok := spec.(*ast.ValueSpec)
					if !ok {
						continue
					}
					for idx, name := range valueSpec.Names {
						if !strings.HasPrefix(name.Name, "commandType") && !strings.HasPrefix(name.Name, "CommandType") {
							continue
						}
						valueExpr := selectValueExpr(valueSpec.Values, idx)
						if valueExpr == nil {
							continue
						}
						value, ok := constantValue(valueExpr, importAliases, root)
						if !ok || strings.TrimSpace(value) == "" {
							continue
						}
						commandValues[name.Name] = value
						byValue[value] = commandDef{
							Owner:     owner,
							Name:      name.Name,
							Value:     value,
							DefinedAt: formatPosition(fset.Position(name.Pos()), root),
						}
					}
				}
			}
		}

		for _, file := range pkg.Files {
			ast.Inspect(file, func(node ast.Node) bool {
				call, ok := node.(*ast.CallExpr)
				if !ok {
					return true
				}
				selector, ok := call.Fun.(*ast.SelectorExpr)
				if !ok || selector.Sel == nil || selector.Sel.Name != "Register" || len(call.Args) != 1 {
					return true
				}
				definitionLit, ok := call.Args[0].(*ast.CompositeLit)
				if !ok || !isDefinitionComposite(definitionLit.Type) {
					return true
				}
				definition, ok := parseCommandDefinitionLiteral(definitionLit, fset, root, owner, commandValues)
				if !ok {
					return true
				}
				current, exists := byValue[definition.Value]
				if !exists {
					byValue[definition.Value] = definition
					return true
				}
				if current.Owner == "" {
					current.Owner = definition.Owner
				}
				if current.Name == "" {
					current.Name = definition.Name
				}
				if current.DefinedAt == "" {
					current.DefinedAt = definition.DefinedAt
				}
				if current.GateScope == "" || current.GateScope == "none" {
					if definition.GateScope != "" {
						current.GateScope = definition.GateScope
						current.AllowWhenOpen = definition.AllowWhenOpen
					}
				}
				byValue[definition.Value] = current
				return true
			})
		}
	}

	result := make([]commandDef, 0, len(byValue))
	for _, definition := range byValue {
		result = append(result, definition)
	}
	sort.Slice(result, func(i, j int) bool {
		return result[i].Value < result[j].Value
	})
	return result, nil
}

func isDefinitionComposite(expr ast.Expr) bool {
	switch typed := expr.(type) {
	case *ast.SelectorExpr:
		return typed.Sel != nil && typed.Sel.Name == "Definition"
	case *ast.Ident:
		return typed.Name == "Definition"
	default:
		return false
	}
}

func parseCommandDefinitionLiteral(lit *ast.CompositeLit, fset *token.FileSet, root, owner string, commandValues map[string]string) (commandDef, bool) {
	definition := commandDef{
		Owner: owner,
	}
	for _, elt := range lit.Elts {
		kv, ok := elt.(*ast.KeyValueExpr)
		if !ok {
			continue
		}
		key, ok := kv.Key.(*ast.Ident)
		if !ok {
			continue
		}
		switch key.Name {
		case "Type":
			value := eventValueFromExpr(kv.Value, commandValues)
			if strings.TrimSpace(value) == "" {
				continue
			}
			definition.Value = value
		case "Owner":
			if parsedOwner, ok := commandOwnerFromExpr(kv.Value); ok {
				definition.Owner = parsedOwner
			}
		case "Gate":
			scope, allowWhenOpen := parseGatePolicyFromExpr(kv.Value)
			if strings.TrimSpace(scope) != "" {
				definition.GateScope = scope
				definition.AllowWhenOpen = allowWhenOpen
			}
		}
	}
	if strings.TrimSpace(definition.Value) == "" {
		return commandDef{}, false
	}
	definition.DefinedAt = formatPosition(fset.Position(lit.Pos()), root)
	return definition, true
}

func commandOwnerFromExpr(expr ast.Expr) (string, bool) {
	selector, ok := expr.(*ast.SelectorExpr)
	if !ok || selector.Sel == nil {
		return "", false
	}
	switch selector.Sel.Name {
	case "OwnerCore":
		return "Core", true
	case "OwnerSystem":
		return "System", true
	default:
		return "", false
	}
}

func parseGatePolicyFromExpr(expr ast.Expr) (string, bool) {
	lit, ok := expr.(*ast.CompositeLit)
	if !ok {
		return "", false
	}
	scope := ""
	allowWhenOpen := false
	for _, elt := range lit.Elts {
		kv, ok := elt.(*ast.KeyValueExpr)
		if !ok {
			continue
		}
		key, ok := kv.Key.(*ast.Ident)
		if !ok {
			continue
		}
		switch key.Name {
		case "Scope":
			scope = parseGateScope(kv.Value)
		case "AllowWhenOpen":
			if ident, ok := kv.Value.(*ast.Ident); ok {
				allowWhenOpen = ident.Name == "true"
			}
		}
	}
	return scope, allowWhenOpen
}

func parseGateScope(expr ast.Expr) string {
	switch typed := expr.(type) {
	case *ast.SelectorExpr:
		if typed.Sel == nil {
			return ""
		}
		switch typed.Sel.Name {
		case "GateScopeSession":
			return "session"
		case "GateScopeNone":
			return "none"
		}
	case *ast.BasicLit:
		if typed.Kind != token.STRING {
			return ""
		}
		value, err := strconv.Unquote(typed.Value)
		if err != nil {
			return ""
		}
		return strings.TrimSpace(value)
	}
	return ""
}

func mergeCommandDefinitions(target map[string]commandDef, definitions []commandDef) {
	for _, definition := range definitions {
		current, exists := target[definition.Value]
		if !exists {
			target[definition.Value] = definition
			continue
		}
		if current.Owner == "" {
			current.Owner = definition.Owner
		}
		if current.Name == "" {
			current.Name = definition.Name
		}
		if current.DefinedAt == "" {
			current.DefinedAt = definition.DefinedAt
		}
		if current.GateScope == "" || current.GateScope == "none" {
			if definition.GateScope != "" {
				current.GateScope = definition.GateScope
				current.AllowWhenOpen = definition.AllowWhenOpen
			}
		}
		target[definition.Value] = current
	}
}

func commandDefinitionsFromMap(definitions map[string]commandDef) []commandDef {
	if len(definitions) == 0 {
		return nil
	}
	result := make([]commandDef, 0, len(definitions))
	for _, definition := range definitions {
		result = append(result, definition)
	}
	sort.Slice(result, func(i, j int) bool {
		return result[i].Value < result[j].Value
	})
	return result
}

func parseConstDecl(decl *ast.GenDecl, fset *token.FileSet, root, owner string, importAliases map[string]string) []eventDef {
	var events []eventDef
	for _, spec := range decl.Specs {
		valueSpec, ok := spec.(*ast.ValueSpec)
		if !ok {
			continue
		}
		typeString := ""
		if valueSpec.Type != nil {
			typeString = exprString(fset, valueSpec.Type)
			switch typeString {
			case "Type", "EventType", "event.Type", "event.EventType":
			default:
				continue
			}
		}
		for idx, name := range valueSpec.Names {
			if !isEventTypeConstant(name.Name) {
				continue
			}
			if !isExported(name.Name) && !strings.HasPrefix(name.Name, "eventType") {
				continue
			}
			valueExpr := selectValueExpr(valueSpec.Values, idx)
			if valueExpr == nil {
				continue
			}
			if valueSpec.Type == nil {
				if _, ok := valueExpr.(*ast.SelectorExpr); !ok {
					continue
				}
			}
			value, ok := constantValue(valueExpr, importAliases, root)
			if !ok {
				continue
			}
			events = append(events, eventDef{
				Owner:     owner,
				Name:      name.Name,
				Value:     value,
				DefinedAt: formatPosition(fset.Position(name.Pos()), root),
			})
		}
	}
	return events
}

func isEventTypeConstant(name string) bool {
	return strings.HasPrefix(name, "Type") || strings.HasPrefix(name, "EventType") || strings.HasPrefix(name, "eventType")
}

func parsePayloadFields(fields *ast.FieldList, fset *token.FileSet) []payloadField {
	if fields == nil {
		return nil
	}
	results := make([]payloadField, 0)
	for _, field := range fields.List {
		if len(field.Names) == 0 {
			continue
		}
		typeString := exprString(fset, field.Type)
		jsonTag := ""
		if field.Tag != nil {
			tagValue, err := strconv.Unquote(field.Tag.Value)
			if err == nil {
				tag := reflect.StructTag(tagValue)
				if jsonValue := tag.Get("json"); jsonValue != "" {
					jsonTag = fmt.Sprintf("json:\"%s\"", jsonValue)
				}
			}
		}
		for _, name := range field.Names {
			results = append(results, payloadField{
				Name:    name.Name,
				Type:    typeString,
				JSONTag: jsonTag,
			})
		}
	}
	return results
}

func parsePayloadFromTypeExpr(expr ast.Expr, fset *token.FileSet, importAliases map[string]string, root string, typeSpecs map[string]ast.Expr, seen map[string]struct{}) ([]payloadField, string, bool) {
	switch typed := expr.(type) {
	case *ast.StructType:
		return parsePayloadFields(typed.Fields, fset), formatPosition(fset.Position(typed.Pos()), root), true
	case *ast.SelectorExpr:
		return parseImportedPayload(typed, importAliases, root)
	case *ast.Ident:
		name := typed.Name
		if _, ok := seen[name]; ok {
			return nil, "", false
		}
		target, ok := typeSpecs[name]
		if !ok {
			return nil, "", false
		}
		next := make(map[string]struct{}, len(seen)+1)
		for k := range seen {
			next[k] = struct{}{}
		}
		next[name] = struct{}{}
		return parsePayloadFromTypeExpr(target, fset, importAliases, root, typeSpecs, next)
	default:
		return nil, "", false
	}
}

func parseImportedPayload(sel *ast.SelectorExpr, importAliases map[string]string, root string) ([]payloadField, string, bool) {
	alias := sel.X
	ident, ok := alias.(*ast.Ident)
	if !ok {
		return nil, "", false
	}
	importPath, ok := importAliases[ident.Name]
	if !ok {
		return nil, "", false
	}
	importDir := resolveImportDir(importPath, root)
	if importDir == "" {
		return nil, "", false
	}
	return parsePayloadFromPackage(importDir, sel.Sel.Name, root)
}

func parsePayloadFromPackage(dir, typeName, root string) ([]payloadField, string, bool) {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, func(info os.FileInfo) bool {
		return !strings.HasSuffix(info.Name(), "_test.go")
	}, parser.AllErrors)
	if err != nil {
		return nil, "", false
	}
	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			for _, decl := range file.Decls {
				gen, ok := decl.(*ast.GenDecl)
				if !ok || gen.Tok != token.TYPE {
					continue
				}
				for _, spec := range gen.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok || typeSpec.Name.Name != typeName {
						continue
					}
					structType, ok := typeSpec.Type.(*ast.StructType)
					if !ok {
						continue
					}
					return parsePayloadFields(structType.Fields, fset), formatPosition(fset.Position(typeSpec.Pos()), root), true
				}
			}
		}
	}
	return nil, "", false
}

func parseImportAliases(file *ast.File) map[string]string {
	aliases := make(map[string]string)
	for _, imp := range file.Imports {
		pathValue, err := strconv.Unquote(imp.Path.Value)
		if err != nil {
			continue
		}
		name := filepath.Base(pathValue)
		if imp.Name != nil && imp.Name.Name != "" && imp.Name.Name != "." && imp.Name.Name != "_" {
			name = imp.Name.Name
		}
		aliases[name] = pathValue
	}
	// Default import name is package identifier.
	return aliases
}

// modulePathByRoot caches the module path read from go.mod for each root directory.
var modulePathByRoot = make(map[string]string)

// defaultModulePath is the fallback when go.mod cannot be read from root.
const defaultModulePath = "github.com/louisbranch/fracturing.space"

// resolveModulePath reads the module path from go.mod in the given root directory,
// falling back to the default project module path when go.mod is absent.
func resolveModulePath(root string) string {
	if cached, ok := modulePathByRoot[root]; ok {
		return cached
	}
	data, err := os.ReadFile(filepath.Join(root, "go.mod"))
	if err != nil {
		modulePathByRoot[root] = defaultModulePath
		return defaultModulePath
	}
	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module ") {
			modulePath := strings.TrimSpace(strings.TrimPrefix(line, "module"))
			modulePathByRoot[root] = modulePath
			return modulePath
		}
	}
	modulePathByRoot[root] = defaultModulePath
	return defaultModulePath
}

func resolveImportDir(importPath, root string) string {
	modulePath := resolveModulePath(root)
	if modulePath == "" {
		return ""
	}
	prefix := modulePath + "/"
	if !strings.HasPrefix(importPath, prefix) {
		return ""
	}
	relPath := strings.TrimPrefix(importPath, prefix)
	candidate := filepath.Join(root, filepath.FromSlash(relPath))
	if _, err := os.Stat(candidate); err != nil {
		return ""
	}
	return candidate
}

func constantValue(expr ast.Expr, importAliases map[string]string, root string) (string, bool) {
	lit, ok := expr.(*ast.BasicLit)
	if !ok || lit.Kind != token.STRING {
		if sel, ok := expr.(*ast.SelectorExpr); ok {
			return constFromSelector(sel, importAliases, root)
		}
		return "", false
	}
	value, err := strconv.Unquote(lit.Value)
	if err != nil {
		return "", false
	}
	return value, true
}

func constFromSelector(expr *ast.SelectorExpr, importAliases map[string]string, root string) (string, bool) {
	alias := expr.X
	ident, ok := alias.(*ast.Ident)
	if !ok {
		return "", false
	}
	importPath, ok := importAliases[ident.Name]
	if !ok {
		return "", false
	}
	importDir := resolveImportDir(importPath, root)
	if importDir == "" {
		return "", false
	}
	return constFromPackage(importDir, expr.Sel.Name)
}

func constFromPackage(dir, constantName string) (string, bool) {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, func(info os.FileInfo) bool {
		return !strings.HasSuffix(info.Name(), "_test.go")
	}, parser.AllErrors)
	if err != nil {
		return "", false
	}
	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			for _, decl := range file.Decls {
				gen, ok := decl.(*ast.GenDecl)
				if !ok || gen.Tok != token.CONST {
					continue
				}
				for _, spec := range gen.Specs {
					valueSpec, ok := spec.(*ast.ValueSpec)
					if !ok {
						continue
					}
					for i, name := range valueSpec.Names {
						if name.Name != constantName {
							continue
						}
						valueExpr := selectValueExpr(valueSpec.Values, i)
						if valueExpr == nil {
							continue
						}
						value, ok := constantValue(valueExpr, nil, dir)
						if ok {
							return value, true
						}
					}
				}
			}
		}
	}
	return "", false
}

func isExported(name string) bool {
	if name == "" {
		return false
	}
	return unicode.IsUpper(rune(name[0]))
}

func selectValueExpr(values []ast.Expr, index int) ast.Expr {
	if len(values) == 0 {
		return nil
	}
	if len(values) == 1 {
		return values[0]
	}
	if index < len(values) {
		return values[index]
	}
	return nil
}

func scanEmitters(dir, root string) (map[string][]string, error) {
	emitters := make(map[string][]string)
	if err := filepath.WalkDir(dir, func(path string, entry os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if entry.IsDir() {
			return nil
		}
		if !strings.HasSuffix(entry.Name(), ".go") || strings.HasSuffix(entry.Name(), "_test.go") {
			return nil
		}
		fset := token.NewFileSet()
		file, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
		if err != nil {
			return fmt.Errorf("parse %s: %w", path, err)
		}
		relPath, _ := filepath.Rel(root, path)
		ast.Inspect(file, func(node ast.Node) bool {
			lit, ok := node.(*ast.CompositeLit)
			if !ok {
				return true
			}
			selector, ok := lit.Type.(*ast.SelectorExpr)
			if !ok {
				return true
			}
			ident, ok := selector.X.(*ast.Ident)
			if !ok || ident.Name != "event" || selector.Sel.Name != "Event" {
				return true
			}
			for _, elt := range lit.Elts {
				kv, ok := elt.(*ast.KeyValueExpr)
				if !ok {
					continue
				}
				key, ok := kv.Key.(*ast.Ident)
				if !ok || key.Name != "Type" {
					continue
				}
				eventName := eventNameFromExpr(kv.Value)
				if eventName == "" {
					continue
				}
				pos := fset.Position(kv.Value.Pos())
				location := fmt.Sprintf("%s:%d", relPath, pos.Line)
				emitters[eventName] = append(emitters[eventName], location)
			}
			return true
		})
		return nil
	}); err != nil {
		return nil, err
	}
	for key := range emitters {
		sort.Strings(emitters[key])
	}
	return emitters, nil
}

func eventNameFromExpr(expr ast.Expr) string {
	switch typed := expr.(type) {
	case *ast.SelectorExpr:
		return typed.Sel.Name
	case *ast.Ident:
		return typed.Name
	default:
		return ""
	}
}

func buildEventValueLookup(packages []packageDefs) map[string]string {
	lookup := make(map[string]string)
	for _, pkg := range packages {
		for _, evt := range pkg.Events {
			if strings.TrimSpace(evt.Name) == "" || strings.TrimSpace(evt.Value) == "" {
				continue
			}
			lookup[evt.Name] = evt.Value
		}
	}
	return lookup
}

func buildLocalConstLookup(file *ast.File, seed map[string]string) map[string]string {
	lookup := make(map[string]string, len(seed))
	for key, value := range seed {
		lookup[key] = value
	}

	type pendingConst struct {
		name string
		expr ast.Expr
	}
	pending := make([]pendingConst, 0)

	for _, decl := range file.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok != token.CONST {
			continue
		}
		for _, spec := range gen.Specs {
			valueSpec, ok := spec.(*ast.ValueSpec)
			if !ok {
				continue
			}
			for i, name := range valueSpec.Names {
				expr := selectValueExpr(valueSpec.Values, i)
				if expr == nil {
					continue
				}
				value := eventValueFromExpr(expr, lookup)
				if value != "" {
					lookup[name.Name] = value
					continue
				}
				pending = append(pending, pendingConst{name: name.Name, expr: expr})
			}
		}
	}

	changed := true
	for changed {
		changed = false
		remaining := make([]pendingConst, 0, len(pending))
		for _, item := range pending {
			value := eventValueFromExpr(item.expr, lookup)
			if value == "" {
				remaining = append(remaining, item)
				continue
			}
			lookup[item.name] = value
			changed = true
		}
		pending = remaining
	}

	return lookup
}

func scanEmitterValues(dir, root string, valueByConstant map[string]string) (map[string][]string, error) {
	emitters := make(map[string][]string)
	if err := filepath.WalkDir(dir, func(path string, entry os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if entry.IsDir() {
			return nil
		}
		if !strings.HasSuffix(entry.Name(), ".go") || strings.HasSuffix(entry.Name(), "_test.go") {
			return nil
		}
		fset := token.NewFileSet()
		file, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
		if err != nil {
			return fmt.Errorf("parse %s: %w", path, err)
		}
		fileLookup := buildLocalConstLookup(file, valueByConstant)
		importAliases := parseImportAliases(file)
		relPath, _ := filepath.Rel(root, path)
		relPath = filepath.ToSlash(relPath)
		ast.Inspect(file, func(node ast.Node) bool {
			// Match event.Event{Type: <eventType>, ...} struct literals.
			if lit, ok := node.(*ast.CompositeLit); ok {
				selector, ok := lit.Type.(*ast.SelectorExpr)
				if !ok {
					return true
				}
				ident, ok := selector.X.(*ast.Ident)
				if !ok || ident.Name != "event" || selector.Sel.Name != "Event" {
					return true
				}
				for _, elt := range lit.Elts {
					kv, ok := elt.(*ast.KeyValueExpr)
					if !ok {
						continue
					}
					key, ok := kv.Key.(*ast.Ident)
					if !ok || key.Name != "Type" {
						continue
					}
					value := resolveEventValue(kv.Value, fileLookup, importAliases, root)
					if value == "" {
						continue
					}
					pos := fset.Position(kv.Value.Pos())
					location := fmt.Sprintf("%s:%d", relPath, pos.Line)
					emitters[value] = append(emitters[value], location)
				}
				return true
			}
			// Match command.NewEvent(cmd, <eventType>, ...) calls.
			if call, ok := node.(*ast.CallExpr); ok {
				if isCommandNewEventCall(call) && len(call.Args) >= 2 {
					value := resolveEventValue(call.Args[1], fileLookup, importAliases, root)
					if value != "" {
						pos := fset.Position(call.Args[1].Pos())
						location := fmt.Sprintf("%s:%d", relPath, pos.Line)
						emitters[value] = append(emitters[value], location)
					}
				}
			}
			return true
		})
		return nil
	}); err != nil {
		return nil, err
	}
	for key := range emitters {
		emitters[key] = sortedUnique(emitters[key])
	}
	return emitters, nil
}

func scanAppliers(dir, root string, valueByConstant map[string]string) (map[string][]string, error) {
	appliers := make(map[string][]string)
	if err := filepath.WalkDir(dir, func(path string, entry os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if entry.IsDir() {
			return nil
		}
		if !strings.HasSuffix(entry.Name(), ".go") || strings.HasSuffix(entry.Name(), "_test.go") {
			return nil
		}
		fset := token.NewFileSet()
		file, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
		if err != nil {
			return fmt.Errorf("parse %s: %w", path, err)
		}
		fileLookup := buildLocalConstLookup(file, valueByConstant)
		importAliases := parseImportAliases(file)
		relPath, _ := filepath.Rel(root, path)
		relPath = filepath.ToSlash(relPath)
		ast.Inspect(file, func(node ast.Node) bool {
			fn, ok := node.(*ast.FuncDecl)
			if !ok || fn.Body == nil || fn.Name == nil || fn.Name.Name != "Apply" {
				return true
			}
			ast.Inspect(fn.Body, func(inner ast.Node) bool {
				switchStmt, ok := inner.(*ast.SwitchStmt)
				if !ok || !switchesOnEventType(switchStmt.Tag) {
					return true
				}
				for _, stmt := range switchStmt.Body.List {
					caseClause, ok := stmt.(*ast.CaseClause)
					if !ok {
						continue
					}
					for _, expr := range caseClause.List {
						value := resolveEventValue(expr, fileLookup, importAliases, root)
						if value == "" {
							continue
						}
						pos := fset.Position(expr.Pos())
						location := fmt.Sprintf("%s:%d", relPath, pos.Line)
						appliers[value] = append(appliers[value], location)
					}
				}
				return true
			})
			return false
		})
		return nil
	}); err != nil {
		return nil, err
	}
	for key := range appliers {
		appliers[key] = sortedUnique(appliers[key])
	}
	return appliers, nil
}

func switchesOnEventType(tag ast.Expr) bool {
	selector, ok := tag.(*ast.SelectorExpr)
	if !ok {
		return false
	}
	return selector.Sel != nil && selector.Sel.Name == "Type"
}

// isCommandNewEventCall returns true when the call expression is command.NewEvent(...).
func isCommandNewEventCall(call *ast.CallExpr) bool {
	sel, ok := call.Fun.(*ast.SelectorExpr)
	if !ok {
		return false
	}
	ident, ok := sel.X.(*ast.Ident)
	if !ok {
		return false
	}
	return ident.Name == "command" && sel.Sel.Name == "NewEvent"
}

// resolveEventValue resolves an event value expression, preferring precise
// cross-package resolution for qualified selectors (e.g. campaign.EventTypeCreated)
// to avoid collisions when multiple packages export the same constant name.
func resolveEventValue(expr ast.Expr, fileLookup map[string]string, importAliases map[string]string, root string) string {
	if sel, ok := expr.(*ast.SelectorExpr); ok {
		if v, ok := constFromSelector(sel, importAliases, root); ok {
			return v
		}
	}
	return eventValueFromExpr(expr, fileLookup)
}

func eventValueFromExpr(expr ast.Expr, valueByConstant map[string]string) string {
	switch typed := expr.(type) {
	case *ast.BasicLit:
		if typed.Kind != token.STRING {
			return ""
		}
		value, err := strconv.Unquote(typed.Value)
		if err != nil {
			return ""
		}
		return strings.TrimSpace(value)
	case *ast.CallExpr:
		if len(typed.Args) != 1 {
			return ""
		}
		return eventValueFromExpr(typed.Args[0], valueByConstant)
	case *ast.Ident:
		return strings.TrimSpace(valueByConstant[typed.Name])
	case *ast.SelectorExpr:
		return strings.TrimSpace(valueByConstant[typed.Sel.Name])
	default:
		return ""
	}
}

func sortedUnique(values []string) []string {
	if len(values) == 0 {
		return nil
	}
	sort.Strings(values)
	result := make([]string, 0, len(values))
	for _, value := range values {
		if len(result) > 0 && result[len(result)-1] == value {
			continue
		}
		result = append(result, value)
	}
	return result
}

func splitEventValue(value string) (string, string) {
	parts := strings.SplitN(value, ".", 2)
	if len(parts) == 2 {
		return parts[0], parts[1]
	}
	if value == "" {
		return "(none)", "(none)"
	}
	return "(none)", value
}

func parseJSONTag(jsonTag, fieldName string) (string, bool) {
	if jsonTag == "" {
		return fieldName, true
	}
	const prefix = `json:"`
	if !strings.HasPrefix(jsonTag, prefix) || !strings.HasSuffix(jsonTag, `"`) {
		return jsonTag, true
	}
	tag := strings.TrimSuffix(strings.TrimPrefix(jsonTag, prefix), `"`)
	parts := strings.Split(tag, ",")
	name := parts[0]
	if name == "" {
		name = fieldName
	}
	required := true
	for _, option := range parts[1:] {
		if option == "omitempty" {
			required = false
		}
	}
	return name, required
}

func renderCatalog(packages []packageDefs, emitters map[string][]string) (string, error) {
	payloadByEventValue := buildPayloadByEventValue(packages)
	packages = mergePackageDefsByOwner(packages)
	var buf bytes.Buffer
	buf.WriteString("---\n")
	buf.WriteString("title: \"Event Catalog\"\n")
	buf.WriteString("parent: \"Events\"\n")
	buf.WriteString("nav_order: 1\n")
	buf.WriteString("---\n\n")
	buf.WriteString("# Event Catalog\n\n")
	buf.WriteString(generatedByLine)

	for _, pkg := range packages {
		if len(pkg.Events) == 0 {
			continue
		}
		sort.Slice(pkg.Events, func(i, j int) bool {
			if pkg.Events[i].Value == pkg.Events[j].Value {
				return pkg.Events[i].Name < pkg.Events[j].Name
			}
			return pkg.Events[i].Value < pkg.Events[j].Value
		})
		buf.WriteString(fmt.Sprintf("## %s Events\n\n", pkg.Events[0].Owner))
		buf.WriteString("### Summary\n\n")
		buf.WriteString("| Event | Namespace | Name | Constant | Payload | Emitters |\n")
		buf.WriteString("| --- | --- | --- | --- | --- | --- |\n")
		for _, evt := range pkg.Events {
			namespace, eventName := splitEventValue(evt.Value)
			payload, hasPayload := resolveCatalogPayload(evt, pkg, payloadByEventValue)
			payloadLabel := "not found"
			if hasPayload {
				payloadLabel = fmt.Sprintf("`%s`", payload.Name)
			}
			buf.WriteString(fmt.Sprintf(
				"| `%s` | `%s` | `%s` | `%s` | %s | %d |\n",
				evt.Value,
				namespace,
				eventName,
				evt.Name,
				payloadLabel,
				len(emitters[evt.Value]),
			))
		}
		buf.WriteString("\n")

		usedPayloads := make(map[string]struct{})
		currentNamespace := ""
		for _, evt := range pkg.Events {
			payload, hasPayload := resolveCatalogPayload(evt, pkg, payloadByEventValue)
			if hasPayload {
				usedPayloads[payload.Name] = struct{}{}
			}

			namespace, _ := splitEventValue(evt.Value)
			if namespace != currentNamespace {
				buf.WriteString(fmt.Sprintf("### Namespace `%s`\n\n", namespace))
				currentNamespace = namespace
			}
			buf.WriteString(fmt.Sprintf("#### `%s`\n", evt.Value))
			buf.WriteString(fmt.Sprintf("- Constant: `%s`\n", evt.Name))
			buf.WriteString(fmt.Sprintf("- Defined at: `%s`\n", evt.DefinedAt))
			if hasPayload {
				buf.WriteString(fmt.Sprintf("- Payload: `%s` (`%s`)\n", payload.Name, payload.DefinedAt))
				if len(payload.Fields) > 0 {
					buf.WriteString("- Fields:\n\n")
					buf.WriteString("| Field | JSON | Type | Required |\n")
					buf.WriteString("| --- | --- | --- | --- |\n")
					for _, field := range payload.Fields {
						jsonName, required := parseJSONTag(field.JSONTag, field.Name)
						requiredLabel := "yes"
						if !required {
							requiredLabel = "no"
						}
						buf.WriteString(fmt.Sprintf(
							"| `%s` | `%s` | `%s` | %s |\n",
							field.Name,
							jsonName,
							field.Type,
							requiredLabel,
						))
					}
					buf.WriteString("\n")
				}
			} else {
				buf.WriteString("- Payload: not found\n")
			}
			if locations, ok := emitters[evt.Value]; ok && len(locations) > 0 {
				buf.WriteString("- Emitters:\n")
				for _, location := range locations {
					buf.WriteString(fmt.Sprintf("  - `%s`\n", location))
				}
			}
			buf.WriteString("\n")
		}

		unmapped := unmappedPayloads(pkg.Payloads, usedPayloads)
		if len(unmapped) > 0 {
			buf.WriteString("### Unmapped Payloads\n")
			for _, payload := range unmapped {
				buf.WriteString(fmt.Sprintf("- `%s` (`%s`)\n", payload.Name, payload.DefinedAt))
			}
			buf.WriteString("\n")
		}
	}

	return buf.String(), nil
}

func resolveCatalogPayload(evt eventDef, pkg packageDefs, payloadByEventValue map[string]payloadDef) (payloadDef, bool) {
	if payload, ok := payloadByEventValue[strings.TrimSpace(evt.Value)]; ok {
		return payload, true
	}
	payloadName := strings.TrimSpace(evt.Payload)
	if payloadName == "" {
		payloadName = payloadNameForEvent(evt.Name, evt.Owner)
	}
	payload, ok := pkg.Payloads[payloadName]
	return payload, ok
}

func buildPayloadByEventValue(packages []packageDefs) map[string]payloadDef {
	byEvent := make(map[string]payloadDef)
	for _, pkg := range packages {
		for _, evt := range pkg.Events {
			eventValue := strings.TrimSpace(evt.Value)
			if eventValue == "" {
				continue
			}
			payloadName := strings.TrimSpace(evt.Payload)
			if payloadName == "" {
				payloadName = payloadNameForEvent(evt.Name, evt.Owner)
			}
			payload, ok := pkg.Payloads[payloadName]
			if !ok {
				continue
			}
			byEvent[eventValue] = payload
		}
	}
	return byEvent
}

func renderUsageMap(packages []packageDefs, emitters map[string][]string, appliers map[string][]string) (string, error) {
	packages = mergePackageDefsByOwner(packages)
	var buf bytes.Buffer
	buf.WriteString("---\n")
	buf.WriteString("title: \"Event Usage Map\"\n")
	buf.WriteString("parent: \"Events\"\n")
	buf.WriteString("nav_order: 3\n")
	buf.WriteString("---\n\n")
	buf.WriteString("# Event Usage Map\n\n")
	buf.WriteString(generatedByLine)

	for _, pkg := range packages {
		if len(pkg.Events) == 0 {
			continue
		}
		sort.Slice(pkg.Events, func(i, j int) bool {
			if pkg.Events[i].Value == pkg.Events[j].Value {
				return pkg.Events[i].Name < pkg.Events[j].Name
			}
			return pkg.Events[i].Value < pkg.Events[j].Value
		})
		buf.WriteString(fmt.Sprintf("## %s Events\n\n", pkg.Events[0].Owner))
		for _, evt := range pkg.Events {
			buf.WriteString(fmt.Sprintf("### `%s`\n", evt.Value))
			emitterLocations := sortedUnique(emitters[evt.Value])
			if len(emitterLocations) == 0 {
				buf.WriteString("- Emitters: none found\n")
			} else {
				buf.WriteString("- Emitters:\n")
				for _, location := range emitterLocations {
					buf.WriteString(fmt.Sprintf("  - `%s`\n", location))
				}
			}
			applierLocations := sortedUnique(appliers[evt.Value])
			if len(applierLocations) == 0 {
				buf.WriteString("- Appliers: none found\n")
			} else {
				buf.WriteString("- Appliers:\n")
				for _, location := range applierLocations {
					buf.WriteString(fmt.Sprintf("  - `%s`\n", location))
				}
			}
			buf.WriteString("\n")
		}
	}

	return buf.String(), nil
}

func mergePackageDefsByOwner(packages []packageDefs) []packageDefs {
	type packageSet struct {
		events   []eventDef
		payloads map[string]payloadDef
	}
	grouped := make(map[string]*packageSet)
	ownerOrder := make([]string, 0, len(packages))
	for _, pkg := range packages {
		if len(pkg.Events) == 0 {
			continue
		}
		owner := strings.TrimSpace(pkg.Events[0].Owner)
		if owner == "" {
			continue
		}
		set, ok := grouped[owner]
		if !ok {
			group := &packageSet{
				payloads: make(map[string]payloadDef),
			}
			grouped[owner] = group
			ownerOrder = append(ownerOrder, owner)
			set = group
		}
		set.events = append(set.events, pkg.Events...)
		for name, payload := range pkg.Payloads {
			set.payloads[name] = payload
		}
	}
	result := make([]packageDefs, 0, len(ownerOrder))
	for _, owner := range ownerOrder {
		group := grouped[owner]
		group.events = dedupeEventDefinitionsByValue(group.events)
		result = append(result, packageDefs{
			Events:   group.events,
			Payloads: group.payloads,
		})
	}
	return result
}

func renderCommandCatalog(definitions []commandDef) (string, error) {
	var buf bytes.Buffer
	buf.WriteString("---\n")
	buf.WriteString("title: \"Command Catalog\"\n")
	buf.WriteString("parent: \"Events\"\n")
	buf.WriteString("nav_order: 2\n")
	buf.WriteString("---\n\n")
	buf.WriteString("# Command Catalog\n\n")
	buf.WriteString(generatedByLine)

	if len(definitions) == 0 {
		return buf.String(), nil
	}
	sort.Slice(definitions, func(i, j int) bool {
		return strings.TrimSpace(definitions[i].Value) < strings.TrimSpace(definitions[j].Value)
	})

	core := make([]commandDef, 0, len(definitions))
	system := make([]commandDef, 0, len(definitions))
	for _, definition := range definitions {
		switch strings.TrimSpace(strings.ToLower(definition.Owner)) {
		case "core":
			core = append(core, definition)
		case "system":
			system = append(system, definition)
		}
	}

	writeCommandSection(&buf, "Core Commands", core)
	writeCommandSection(&buf, "System Commands", system)
	return buf.String(), nil
}

func writeCommandSection(buf *bytes.Buffer, title string, definitions []commandDef) {
	if len(definitions) == 0 {
		return
	}
	buf.WriteString(fmt.Sprintf("## %s\n\n", title))
	buf.WriteString("| Command | Namespace | Gate Scope | Allowed When Open |\n")
	buf.WriteString("| --- | --- | --- | --- |\n")
	for _, definition := range definitions {
		commandType := strings.TrimSpace(definition.Value)
		namespace, _ := splitEventValue(commandType)
		gateScope := "none"
		allowWhenOpen := "n/a"
		if strings.TrimSpace(definition.GateScope) != "" {
			gateScope = strings.TrimSpace(definition.GateScope)
		}
		if gateScope != "none" {
			if definition.AllowWhenOpen {
				allowWhenOpen = "yes"
			} else {
				allowWhenOpen = "no"
			}
		}
		buf.WriteString(fmt.Sprintf(
			"| `%s` | `%s` | `%s` | %s |\n",
			commandType,
			namespace,
			gateScope,
			allowWhenOpen,
		))
	}
	buf.WriteString("\n")
}

func payloadNameForEvent(eventName, owner string) string {
	switch {
	case strings.HasPrefix(eventName, "Type"):
		return strings.TrimPrefix(eventName, "Type") + "Payload"
	case strings.HasPrefix(eventName, "EventType"):
		return strings.TrimPrefix(eventName, "EventType") + "Payload"
	case strings.HasPrefix(eventName, "eventType"):
		return strings.TrimPrefix(eventName, "eventType") + "Payload"
	case strings.TrimSpace(owner) == "":
		return ""
	}
	return ""
}

func unmappedPayloads(payloads map[string]payloadDef, used map[string]struct{}) []payloadDef {
	if len(payloads) == 0 {
		return nil
	}
	result := make([]payloadDef, 0)
	for name, payload := range payloads {
		if _, ok := used[name]; ok {
			continue
		}
		result = append(result, payload)
	}
	sort.Slice(result, func(i, j int) bool { return result[i].Name < result[j].Name })
	return result
}

func exprString(fset *token.FileSet, expr ast.Expr) string {
	var buf bytes.Buffer
	_ = printer.Fprint(&buf, fset, expr)
	return buf.String()
}

func formatPosition(pos token.Position, root string) string {
	rel, err := filepath.Rel(root, pos.Filename)
	if err != nil {
		rel = pos.Filename
	}
	return fmt.Sprintf("%s:%d", filepath.ToSlash(rel), pos.Line)
}

func fatal(err error) {
	fmt.Fprintln(os.Stderr, err)
	os.Exit(1)
}
