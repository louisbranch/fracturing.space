package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

const generatedHeader = "# Code generated by go run ./internal/tools/topologygen; DO NOT EDIT.\n"

type catalog struct {
	Version  int       `json:"version"`
	Services []service `json:"services"`
}

type service struct {
	Name         string        `json:"name"`
	GRPCPort     int           `json:"grpc_port,omitempty"`
	HTTPPort     int           `json:"http_port,omitempty"`
	PublicRoutes []publicRoute `json:"public_routes,omitempty"`
}

type publicRoute struct {
	HostPrefix     string `json:"host_prefix"`
	HTTPPort       int    `json:"http_port,omitempty"`
	ExtraDirective string `json:"extra_directive,omitempty"`
}

func main() {
	var rootFlag string
	var catalogPath string
	var outCaddyPath string
	var outComposePath string
	var check bool

	flag.StringVar(&rootFlag, "root", "", "repo root (defaults to locating go.mod)")
	flag.StringVar(&catalogPath, "catalog", "topology/services.json", "service catalog path")
	flag.StringVar(&outCaddyPath, "out-caddy", "Caddyfile.routes.generated", "generated caddy routes output path")
	flag.StringVar(&outComposePath, "out-compose", "topology/generated/docker-compose.discovery.generated.yml", "generated compose discovery output path")
	flag.BoolVar(&check, "check", false, "check generated outputs for drift without writing")
	flag.Parse()

	root, err := resolveRoot(rootFlag)
	if err != nil {
		fatal(err)
	}

	catalogData, err := os.ReadFile(resolvePath(root, catalogPath))
	if err != nil {
		fatal(fmt.Errorf("read catalog: %w", err))
	}
	parsed, err := parseCatalog(catalogData)
	if err != nil {
		fatal(err)
	}
	if err := validateCatalog(parsed); err != nil {
		fatal(err)
	}

	caddyContent, err := renderCaddyRoutes(parsed)
	if err != nil {
		fatal(err)
	}
	composeContent, err := renderComposeDiscovery(parsed)
	if err != nil {
		fatal(err)
	}

	caddyPath := resolvePath(root, outCaddyPath)
	composePath := resolvePath(root, outComposePath)
	if check {
		if err := checkGenerated(caddyPath, caddyContent); err != nil {
			fatal(err)
		}
		if err := checkGenerated(composePath, composeContent); err != nil {
			fatal(err)
		}
		return
	}

	if err := writeGenerated(caddyPath, caddyContent); err != nil {
		fatal(err)
	}
	if err := writeGenerated(composePath, composeContent); err != nil {
		fatal(err)
	}
}

func parseCatalog(data []byte) (catalog, error) {
	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()

	var parsed catalog
	if err := decoder.Decode(&parsed); err != nil {
		return catalog{}, fmt.Errorf("parse catalog json: %w", err)
	}
	if decoder.More() {
		return catalog{}, errors.New("parse catalog json: extra trailing content")
	}
	return parsed, nil
}

func validateCatalog(parsed catalog) error {
	if parsed.Version <= 0 {
		return errors.New("catalog version must be positive")
	}
	if len(parsed.Services) == 0 {
		return errors.New("catalog must define at least one service")
	}

	serviceNames := make(map[string]struct{}, len(parsed.Services))
	normalizedServiceNames := make(map[string]string, len(parsed.Services))
	publicHosts := make(map[string]string)
	for _, svc := range parsed.Services {
		name := strings.TrimSpace(svc.Name)
		if name == "" {
			return errors.New("service name is required")
		}
		if _, exists := serviceNames[name]; exists {
			return fmt.Errorf("duplicate service name %q", name)
		}
		serviceNames[name] = struct{}{}
		normalizedName := normalizeServiceName(name)
		if owner, exists := normalizedServiceNames[normalizedName]; exists {
			return fmt.Errorf("service name %q collides with %q after normalization", name, owner)
		}
		normalizedServiceNames[normalizedName] = name

		if err := validatePort(name, "grpc_port", svc.GRPCPort, true); err != nil {
			return err
		}
		if err := validatePort(name, "http_port", svc.HTTPPort, true); err != nil {
			return err
		}
		if svc.GRPCPort <= 0 && svc.HTTPPort <= 0 {
			return fmt.Errorf("service %q must define grpc_port or http_port", name)
		}

		for _, route := range svc.PublicRoutes {
			hostPrefix := strings.TrimSpace(route.HostPrefix)
			canonicalHostPrefix := strings.ToLower(hostPrefix)
			routePort := route.HTTPPort
			if routePort <= 0 {
				routePort = svc.HTTPPort
			}
			if err := validatePort(name, "public_routes.http_port", routePort, false); err != nil {
				return err
			}
			if owner, exists := publicHosts[canonicalHostPrefix]; exists {
				return fmt.Errorf("duplicate public host_prefix %q for services %q and %q", hostPrefix, owner, name)
			}
			publicHosts[canonicalHostPrefix] = name
		}
	}
	return nil
}

func validatePort(serviceName, field string, port int, allowZero bool) error {
	if port == 0 && allowZero {
		return nil
	}
	if port < 1 || port > 65535 {
		return fmt.Errorf("service %q has invalid %s value %d", serviceName, field, port)
	}
	return nil
}

func renderCaddyRoutes(parsed catalog) (string, error) {
	type route struct {
		site           string
		upstream       string
		hostPrefix     string
		serviceName    string
		port           int
		extraDirective string
	}

	routes := make([]route, 0)
	for _, svc := range parsed.Services {
		for _, candidate := range svc.PublicRoutes {
			port := candidate.HTTPPort
			if port <= 0 {
				port = svc.HTTPPort
			}
			if port <= 0 {
				return "", fmt.Errorf("service %q public route requires http_port", svc.Name)
			}
			prefix := strings.TrimSpace(candidate.HostPrefix)
			routes = append(routes, route{
				site:           routeSite(prefix),
				upstream:       fmt.Sprintf("%s:%d", svc.Name, port),
				hostPrefix:     prefix,
				serviceName:    svc.Name,
				port:           port,
				extraDirective: strings.TrimSpace(candidate.ExtraDirective),
			})
		}
	}
	sort.Slice(routes, func(i, j int) bool {
		if routes[i].hostPrefix != routes[j].hostPrefix {
			return routes[i].hostPrefix < routes[j].hostPrefix
		}
		if routes[i].serviceName != routes[j].serviceName {
			return routes[i].serviceName < routes[j].serviceName
		}
		return routes[i].port < routes[j].port
	})

	var out strings.Builder
	out.WriteString(generatedHeader)
	out.WriteString("\n")
	for index, route := range routes {
		if index > 0 {
			out.WriteString("\n")
		}
		out.WriteString(route.site)
		out.WriteString(" {\n")
		if route.extraDirective != "" {
			out.WriteString("  ")
			out.WriteString(route.extraDirective)
			out.WriteString("\n")
		}
		out.WriteString("  reverse_proxy ")
		out.WriteString(route.upstream)
		out.WriteString("\n")
		out.WriteString("}\n")
	}

	return out.String(), nil
}

func routeSite(hostPrefix string) string {
	if hostPrefix == "" {
		return "{$FRACTURING_SPACE_CADDY_SITE_PREFIX}{$FRACTURING_SPACE_DOMAIN}"
	}
	return "{$FRACTURING_SPACE_CADDY_SITE_PREFIX}" + hostPrefix + ".{$FRACTURING_SPACE_DOMAIN}"
}

func normalizeServiceName(name string) string {
	normalized := strings.ToLower(strings.TrimSpace(name))
	normalized = strings.ReplaceAll(normalized, "-", "_")
	return normalized
}

func renderComposeDiscovery(parsed catalog) (string, error) {
	type entry struct {
		key   string
		value string
	}
	entries := make([]entry, 0, len(parsed.Services)*2)
	for _, svc := range parsed.Services {
		name := strings.TrimSpace(svc.Name)
		if name == "" {
			return "", errors.New("service name is required")
		}
		keyName := normalizeServiceName(name)
		if svc.GRPCPort > 0 {
			entries = append(entries, entry{
				key:   keyName + "_grpc_addr",
				value: fmt.Sprintf("%s:%d", name, svc.GRPCPort),
			})
		}
		if svc.HTTPPort > 0 {
			entries = append(entries, entry{
				key:   keyName + "_http_addr",
				value: fmt.Sprintf("%s:%d", name, svc.HTTPPort),
			})
		}
	}
	sort.Slice(entries, func(i, j int) bool {
		return entries[i].key < entries[j].key
	})

	var out strings.Builder
	out.WriteString(generatedHeader)
	out.WriteString("\n")
	out.WriteString("x-fracturing-space-discovery:\n")
	for _, entry := range entries {
		out.WriteString("  ")
		out.WriteString(entry.key)
		out.WriteString(": ")
		out.WriteString(entry.value)
		out.WriteString("\n")
	}
	return out.String(), nil
}

func writeGenerated(path, content string) error {
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return fmt.Errorf("create output dir for %s: %w", path, err)
	}
	if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
		return fmt.Errorf("write output %s: %w", path, err)
	}
	return nil
}

func checkGenerated(path, expected string) error {
	current, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("read generated output %s: %w", path, err)
	}
	if string(current) != expected {
		return fmt.Errorf("generated output is stale: %s (run: go run ./internal/tools/topologygen)", path)
	}
	return nil
}

func resolveRoot(flagRoot string) (string, error) {
	if strings.TrimSpace(flagRoot) != "" {
		return filepath.Clean(flagRoot), nil
	}
	wd, err := os.Getwd()
	if err != nil {
		return "", fmt.Errorf("get working dir: %w", err)
	}
	return findModuleRoot(wd)
}

func findModuleRoot(start string) (string, error) {
	dir := start
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return "", fmt.Errorf("go.mod not found above %s", start)
}

func resolvePath(root, path string) string {
	if filepath.IsAbs(path) {
		return path
	}
	return filepath.Join(root, path)
}

func fatal(err error) {
	fmt.Fprintf(os.Stderr, "topologygen: %v\n", err)
	os.Exit(1)
}
