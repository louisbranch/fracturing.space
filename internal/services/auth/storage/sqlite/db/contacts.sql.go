// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: contacts.sql

package db

import (
	"context"
)

const deleteContact = `-- name: DeleteContact :exec
DELETE FROM user_contacts
WHERE owner_user_id = ? AND contact_user_id = ?
`

type DeleteContactParams struct {
	OwnerUserID   string `json:"owner_user_id"`
	ContactUserID string `json:"contact_user_id"`
}

func (q *Queries) DeleteContact(ctx context.Context, arg DeleteContactParams) error {
	_, err := q.db.ExecContext(ctx, deleteContact, arg.OwnerUserID, arg.ContactUserID)
	return err
}

const getContact = `-- name: GetContact :one
SELECT owner_user_id, contact_user_id, created_at, updated_at
FROM user_contacts
WHERE owner_user_id = ? AND contact_user_id = ?
`

type GetContactParams struct {
	OwnerUserID   string `json:"owner_user_id"`
	ContactUserID string `json:"contact_user_id"`
}

func (q *Queries) GetContact(ctx context.Context, arg GetContactParams) (UserContact, error) {
	row := q.db.QueryRowContext(ctx, getContact, arg.OwnerUserID, arg.ContactUserID)
	var i UserContact
	err := row.Scan(
		&i.OwnerUserID,
		&i.ContactUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listContactsPaged = `-- name: ListContactsPaged :many
SELECT owner_user_id, contact_user_id, created_at, updated_at
FROM user_contacts
WHERE owner_user_id = ? AND contact_user_id > ?
ORDER BY contact_user_id
LIMIT ?
`

type ListContactsPagedParams struct {
	OwnerUserID   string `json:"owner_user_id"`
	ContactUserID string `json:"contact_user_id"`
	Limit         int64  `json:"limit"`
}

func (q *Queries) ListContactsPaged(ctx context.Context, arg ListContactsPagedParams) ([]UserContact, error) {
	rows, err := q.db.QueryContext(ctx, listContactsPaged, arg.OwnerUserID, arg.ContactUserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserContact{}
	for rows.Next() {
		var i UserContact
		if err := rows.Scan(
			&i.OwnerUserID,
			&i.ContactUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContactsPagedFirst = `-- name: ListContactsPagedFirst :many
SELECT owner_user_id, contact_user_id, created_at, updated_at
FROM user_contacts
WHERE owner_user_id = ?
ORDER BY contact_user_id
LIMIT ?
`

type ListContactsPagedFirstParams struct {
	OwnerUserID string `json:"owner_user_id"`
	Limit       int64  `json:"limit"`
}

func (q *Queries) ListContactsPagedFirst(ctx context.Context, arg ListContactsPagedFirstParams) ([]UserContact, error) {
	rows, err := q.db.QueryContext(ctx, listContactsPagedFirst, arg.OwnerUserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserContact{}
	for rows.Next() {
		var i UserContact
		if err := rows.Scan(
			&i.OwnerUserID,
			&i.ContactUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const putContact = `-- name: PutContact :exec
INSERT INTO user_contacts (
    owner_user_id, contact_user_id, created_at, updated_at
) VALUES (?, ?, ?, ?)
ON CONFLICT(owner_user_id, contact_user_id) DO UPDATE SET
    updated_at = excluded.updated_at
`

type PutContactParams struct {
	OwnerUserID   string `json:"owner_user_id"`
	ContactUserID string `json:"contact_user_id"`
	CreatedAt     int64  `json:"created_at"`
	UpdatedAt     int64  `json:"updated_at"`
}

func (q *Queries) PutContact(ctx context.Context, arg PutContactParams) error {
	_, err := q.db.ExecContext(ctx, putContact,
		arg.OwnerUserID,
		arg.ContactUserID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}
