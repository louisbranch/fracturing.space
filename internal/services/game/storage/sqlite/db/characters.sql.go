// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: characters.sql

package db

import (
	"context"
	"database/sql"
)

const deleteCharacter = `-- name: DeleteCharacter :exec
DELETE FROM characters
WHERE campaign_id = ? AND id = ?
`

type DeleteCharacterParams struct {
	CampaignID string `json:"campaign_id"`
	ID         string `json:"id"`
}

func (q *Queries) DeleteCharacter(ctx context.Context, arg DeleteCharacterParams) error {
	_, err := q.db.ExecContext(ctx, deleteCharacter, arg.CampaignID, arg.ID)
	return err
}

const getCharacter = `-- name: GetCharacter :one
SELECT campaign_id, id, controller_participant_id, name, kind, notes, pronouns, aliases_json, created_at, updated_at, avatar_set_id, avatar_asset_id, owner_participant_id FROM characters WHERE campaign_id = ? AND id = ?
`

type GetCharacterParams struct {
	CampaignID string `json:"campaign_id"`
	ID         string `json:"id"`
}

func (q *Queries) GetCharacter(ctx context.Context, arg GetCharacterParams) (Character, error) {
	row := q.db.QueryRowContext(ctx, getCharacter, arg.CampaignID, arg.ID)
	var i Character
	err := row.Scan(
		&i.CampaignID,
		&i.ID,
		&i.ControllerParticipantID,
		&i.Name,
		&i.Kind,
		&i.Notes,
		&i.Pronouns,
		&i.AliasesJson,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AvatarSetID,
		&i.AvatarAssetID,
		&i.OwnerParticipantID,
	)
	return i, err
}

const listCharactersByCampaign = `-- name: ListCharactersByCampaign :many
SELECT campaign_id, id, controller_participant_id, name, kind, notes, pronouns, aliases_json, created_at, updated_at, avatar_set_id, avatar_asset_id, owner_participant_id FROM characters
WHERE campaign_id = ?
ORDER BY id
`

func (q *Queries) ListCharactersByCampaign(ctx context.Context, campaignID string) ([]Character, error) {
	rows, err := q.db.QueryContext(ctx, listCharactersByCampaign, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Character{}
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.CampaignID,
			&i.ID,
			&i.ControllerParticipantID,
			&i.Name,
			&i.Kind,
			&i.Notes,
			&i.Pronouns,
			&i.AliasesJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AvatarSetID,
			&i.AvatarAssetID,
			&i.OwnerParticipantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharactersByCampaignPaged = `-- name: ListCharactersByCampaignPaged :many
SELECT campaign_id, id, controller_participant_id, name, kind, notes, pronouns, aliases_json, created_at, updated_at, avatar_set_id, avatar_asset_id, owner_participant_id FROM characters
WHERE campaign_id = ? AND id > ?
ORDER BY id
LIMIT ?
`

type ListCharactersByCampaignPagedParams struct {
	CampaignID string `json:"campaign_id"`
	ID         string `json:"id"`
	Limit      int64  `json:"limit"`
}

func (q *Queries) ListCharactersByCampaignPaged(ctx context.Context, arg ListCharactersByCampaignPagedParams) ([]Character, error) {
	rows, err := q.db.QueryContext(ctx, listCharactersByCampaignPaged, arg.CampaignID, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Character{}
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.CampaignID,
			&i.ID,
			&i.ControllerParticipantID,
			&i.Name,
			&i.Kind,
			&i.Notes,
			&i.Pronouns,
			&i.AliasesJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AvatarSetID,
			&i.AvatarAssetID,
			&i.OwnerParticipantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharactersByCampaignPagedFirst = `-- name: ListCharactersByCampaignPagedFirst :many
SELECT campaign_id, id, controller_participant_id, name, kind, notes, pronouns, aliases_json, created_at, updated_at, avatar_set_id, avatar_asset_id, owner_participant_id FROM characters
WHERE campaign_id = ?
ORDER BY id
LIMIT ?
`

type ListCharactersByCampaignPagedFirstParams struct {
	CampaignID string `json:"campaign_id"`
	Limit      int64  `json:"limit"`
}

func (q *Queries) ListCharactersByCampaignPagedFirst(ctx context.Context, arg ListCharactersByCampaignPagedFirstParams) ([]Character, error) {
	rows, err := q.db.QueryContext(ctx, listCharactersByCampaignPagedFirst, arg.CampaignID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Character{}
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.CampaignID,
			&i.ID,
			&i.ControllerParticipantID,
			&i.Name,
			&i.Kind,
			&i.Notes,
			&i.Pronouns,
			&i.AliasesJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AvatarSetID,
			&i.AvatarAssetID,
			&i.OwnerParticipantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const putCharacter = `-- name: PutCharacter :exec
INSERT INTO characters (
    campaign_id, id, owner_participant_id, controller_participant_id, name, kind, notes, avatar_set_id, avatar_asset_id, pronouns, aliases_json, created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(campaign_id, id) DO UPDATE SET
    owner_participant_id = excluded.owner_participant_id,
    controller_participant_id = excluded.controller_participant_id,
    name = excluded.name,
    kind = excluded.kind,
    notes = excluded.notes,
    avatar_set_id = excluded.avatar_set_id,
    avatar_asset_id = excluded.avatar_asset_id,
    pronouns = excluded.pronouns,
    aliases_json = excluded.aliases_json,
    updated_at = excluded.updated_at
`

type PutCharacterParams struct {
	CampaignID              string         `json:"campaign_id"`
	ID                      string         `json:"id"`
	OwnerParticipantID      string         `json:"owner_participant_id"`
	ControllerParticipantID sql.NullString `json:"controller_participant_id"`
	Name                    string         `json:"name"`
	Kind                    string         `json:"kind"`
	Notes                   string         `json:"notes"`
	AvatarSetID             string         `json:"avatar_set_id"`
	AvatarAssetID           string         `json:"avatar_asset_id"`
	Pronouns                string         `json:"pronouns"`
	AliasesJson             string         `json:"aliases_json"`
	CreatedAt               int64          `json:"created_at"`
	UpdatedAt               int64          `json:"updated_at"`
}

func (q *Queries) PutCharacter(ctx context.Context, arg PutCharacterParams) error {
	_, err := q.db.ExecContext(ctx, putCharacter,
		arg.CampaignID,
		arg.ID,
		arg.OwnerParticipantID,
		arg.ControllerParticipantID,
		arg.Name,
		arg.Kind,
		arg.Notes,
		arg.AvatarSetID,
		arg.AvatarAssetID,
		arg.Pronouns,
		arg.AliasesJson,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}
