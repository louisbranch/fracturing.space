package templates

import "fmt"

// EventLogFullPage renders the event log in the base layout.
templ EventLogFullPage(view EventLogView, page PageContext) {
	@Layout(T(page.Loc, "title.events", AppName()), "Campaigns", page.Loc, page, []Breadcrumb{
		{Label: T(page.Loc, "nav.campaigns"), URL: "/campaigns"},
		{Label: view.CampaignName, URL: "/campaigns/" + view.CampaignID},
		{Label: T(page.Loc, "events.heading"), URL: ""},
	}...) {
		@EventLogPage(view, page.Loc)
	}
}

// EventLogPage renders the event log content.
templ EventLogPage(view EventLogView, loc Localizer) {
	@CampaignSubNav(view.CampaignID, "events", loc) {
		<h2>{T(loc, "events.heading")}</h2>
		<p>{ T(loc, "events.count", view.TotalCount) }</p>
		@EventFilterForm(view.CampaignID, view.SessionID, view.Filters, loc)
		<div id="event-timeline-container">
			@EventTimelineContent(view, loc)
		</div>
	}
}

// EventFilterForm renders the filter controls for events.
templ EventFilterForm(campaignID string, sessionID string, filters EventFilterOptions, loc Localizer) {
	<form
		class="border border-base-300 rounded-lg p-4"
		hx-get={ "/campaigns/" + campaignID + "/events/table" }
		hx-target="#event-timeline-container"
		hx-swap="innerHTML"
		hx-push-url="true"
		hx-trigger="change from:select, change from:input[type=date]"
	>
		<div class="grid grid-cols-2 md:grid-cols-4 gap-4">
			<div>
				<label class="label" for="event_type">{T(loc, "events.filter.event_type")}</label>
				<select id="event_type" name="event_type" class="select select-bordered w-full">
					for _, opt := range GetEventTypeOptions(filters.EventType, loc) {
						<option value={ opt.Value } selected?={ opt.Current }>{ opt.Label }</option>
					}
				</select>
			</div>
			<div>
				<label class="label" for="actor_type">{T(loc, "events.filter.actor_type")}</label>
				<select id="actor_type" name="actor_type" class="select select-bordered w-full">
					for _, opt := range GetActorTypeOptions(filters.ActorType, loc) {
						<option value={ opt.Value } selected?={ opt.Current }>{ opt.Label }</option>
					}
				</select>
			</div>
			<div>
				<label class="label" for="entity_type">{T(loc, "events.filter.entity_type")}</label>
				<select id="entity_type" name="entity_type" class="select select-bordered w-full">
					for _, opt := range GetEntityTypeOptions(filters.EntityType, loc) {
						<option value={ opt.Value } selected?={ opt.Current }>{ opt.Label }</option>
					}
				</select>
			</div>
			<div>
				<label class="label" for="start_date">{T(loc, "events.filter.from_date")}</label>
				<input type="date" id="start_date" name="start_date" value={ filters.StartDate } class="input input-bordered w-full"/>
			</div>
			<div>
				<label class="label" for="end_date">{T(loc, "events.filter.to_date")}</label>
				<input type="date" id="end_date" name="end_date" value={ filters.EndDate } class="input input-bordered w-full"/>
			</div>
		</div>
	</form>
}

// EventTimelineContent renders the event timeline with pagination.
templ EventTimelineContent(view EventLogView, loc Localizer) {
	if len(view.Events) == 0 {
		@EmptyState(T(loc, "events.empty"))
	} else {
		<table class="table table-zebra">
			<thead>
				<tr>
					<th>{T(loc, "events.table.event")}</th>
					<th>{T(loc, "events.table.actor")}</th>
					<th>{T(loc, "events.table.entity")}</th>
					<th>{T(loc, "events.table.time")}</th>
				</tr>
			</thead>
			<tbody>
				for _, event := range view.Events {
					@EventTableRow(event, loc)
				}
			</tbody>
		</table>
		@PaginationTargeted(
			view.NextToken,
			view.PrevToken,
			EventFilterBaseURL("/campaigns/"+view.CampaignID+"/events", view.Filters),
			EventFilterBaseURL("/campaigns/"+view.CampaignID+"/events/table", view.Filters),
			"#event-timeline-container",
			true,
			loc,
		)
	}
}

// EventTableRow renders a single event row in a table.
templ EventTableRow(event EventRow, loc Localizer) {
	<tr id={ "event-" + fmt.Sprintf("%d", event.Seq) }>
		<td><strong>{ event.TypeDisplay }</strong></td>
		<td>
			if event.ActorTypeDisplay != "" {
				{ event.ActorTypeDisplay }
			}
		</td>
		<td>
			if event.EntityName != "" {
				{ event.EntityType }: { event.EntityName }
			}
		</td>
		<td>{ event.Timestamp }</td>
	</tr>
	if event.PayloadJSON != "" && event.PayloadJSON != "{}" && event.PayloadJSON != "null" {
		<tr class="payload-row">
			<td colspan="4">
				<details>
					<summary>{T(loc, "events.payload")}</summary>
					<pre><code>{ event.PayloadJSON }</code></pre>
				</details>
			</td>
		</tr>
	}
}

// EventTimeline renders a simple event timeline (for embedding in other pages).
templ EventTimeline(events []EventRow, campaignID string, loc Localizer) {
	if len(events) == 0 {
		@EmptyState(T(loc, "events.timeline.empty"))
	} else {
		<table class="table table-zebra">
			<thead>
				<tr>
					<th>{T(loc, "events.table.event")}</th>
					<th>{T(loc, "events.table.time")}</th>
				</tr>
			</thead>
			<tbody>
				for _, event := range events {
					<tr>
						<td>{ event.TypeDisplay }</td>
						<td>{ event.Timestamp }</td>
					</tr>
				}
			</tbody>
		</table>
	}
}

// EventTimelineItem renders a single event in the timeline (legacy, used by sessions).
templ EventTimelineItem(event EventRow, campaignID string, loc Localizer) {
	@EventTableRow(event, loc)
}

// EventLogTableContent renders just the event table content (for HTMX updates).
templ EventLogTableContent(view EventLogView, loc Localizer) {
	@EventTimelineContent(view, loc)
}
